---
layout: distill
title: "Materials Generation: Inorganic Crystals and Metal-Orgranic Frameworks"
description: 
  In this work, we review to recent works on materials generation. One is SymmCD, which generates inorganic crystals by exploiting the special symmetry property of crystals called 'space groups'. The other is MOFDiff, a coarse-grained diffusion model that generates metal-organic frameworks (MOFs) by exploiting the modular nature of MOFs. 
date: 2025-06-01
future: true
htmlwidgets: true
hidden: false

# Anonymize when submitting
# authors:
#   - name: Anonymous

authors:
  - name: Nayoung Kim
    affiliations:
      name: KAIST


bibliography: 2025-04-28-analysing-the-spectral-biases-in-generative-models.bib  

# Add a table of contents to your post.
#   - make sure that TOC names match the actual section names
#     for hyperlinks within the post to work correctly. 
#   - please use this format rather than manually creating a markdown table of contents.
toc:
  - name: Motivation
    subsections:
      - name: Two Types of Crystals, Two Types of Challenges
  - name: "SymmCD: Symmetry-Preserving Crystal Generation with Diffusion Models"
    subsections:
      - name: "Preliminary: Crystal representation"
      - name: Asymmetric unit and site symmetries
      - name: "Pre-processing: Finding the Asymmetric Unit"
      - name: Training the model
      - name: Sampling and Post-processing
      - name: "Experimental results: what advantages does SymmCD have?"
  - name: "MOFDiff: Coarse-grained Diffusion for Metal-Organic Framework Design"

# Below is an example of injecting additional post-specific styles.
# This is used in the 'Layouts' section of this post.
# If you use this post as a template, delete this _styles block.
_styles: >
  .fake-img {
    background: #bbb;
    border: 1px solid rgba(0, 0, 0, 0.1);
    box-shadow: 0 0px 4px rgba(0, 0, 0, 0.1);
    margin-bottom: 12px;
  }
  .fake-img p {
    font-family: monospace;
    color: white;
    text-align: left;
    margin: 12px 0;
    text-align: center;
    font-size: 16px;
  }
---

<!-- preamble -->
<div class="preamble">
$$
\newcommand{\cM}{\mathcal{M}}
\newcommand{\cA}{\mathcal{A}}
\newcommand{\bA}{\mathbf{A}}
\newcommand{\bX}{\mathbf{X}}
\newcommand{\bL}{\mathbf{L}}
\newcommand{\bS}{\mathbf{S}}
\newcommand{\bbR}{\mathbb{R}}
$$
</div>

## Motivation

Materials span a wide range of structural and chemical complexities, from amorphous polymers to highly ordered solids. Among them, **crystals** refer to materials with a regular, repeating arrangement of atoms or molecules—a periodicity that defines their structure and often their properties. Many everyday materials are crystalline: *diamond*, known for its extreme hardness; *quartz*, used in electronics; and *table salt*, essential in daily life. Designing new crystalline materials with desirable properties is at the heart of breakthroughs in energy, electronics, and environmental sustainability.

The use of deep learning in **crystal generation** -- the automated design of novel crystal structures -- is a rapidly growing research area. Most existing work focuses on **inorganic crystals**, which include materials like semiconductors, superconductors, and catalysts. These materials play a central role in applications such as batteries, solar cells, and thermoelectrics.

A more recent and equally exciting focus has emerged around **metal-organic frameworks (MOFs)**. As the name suggests, MOFs are crystalline materials composed of metal clusters (or nodes) and organic linkers. Their porous structures and high tunability make them promising candidates for gas storage, catalysis, and especially carbon capture, including technologies like direct air capture (DAC) - a critical tool in the fight against climate change.

### Two Types of Crystals, Two Types of Challenges

While both inorganic crystals and MOFs are crystalline, their intrinsic differences pose distinct challenges for generative modeling.
- **Inorganic crystals** tend to have smaller unit cells and fewer atoms per structure. However, they *lack clear modular subunits*, making them harder to decompose or simplify. Each atom’s role and placement are tightly integrated within the overall crystal symmetry.
- **MOFs**, in contrast, can be enormous—sometimes with hundreds or even thousands of atoms per unit cell. Fortunately, they are highly modular, typically composed of well-defined building blocks: metal nodes and organic molecules. This *modularity* invites hierarchical or coarse-grained generation strategies.


|                   |     **Inorganic**       |       **MOF**        |
|-------------------|----------------------|--------------------------|
| Dataset | Materials Project | Core MOF, BW-DB | 
| Size    | ~10-50 atoms/unit cell | ~50-2000 atoms/unit cell|
| Key structural trait | symmetry-rich | modular |
| Generation challenge | symmetry | scale | 


In this blogpost, we explore two recent generative models that address these distinct challenges:
- **SymmCD (ICLR 2025)** targets *inorganic crystals* using a diffusion model with explicit symmetry considerations. By learning to generate only the *asymmetric unit* (the minimal building block of a crystal) and expanding it via symmetry operations, it ensures validity and efficiency in generation.
- **MOFDiff (ICLR 2024)** focuses on *metal-organic frameworks*, leveraging their modularity through a *coarse-grained representation*. Instead of generating atoms directly, MOFDiff learns to assemble metal and organic fragments into full MOF structures using a score-based generative model.

Here’s a quick comparison:

|                   |     **SymmCD**       |       **MOFDiff**        |
|-------------------|----------------------|--------------------------|
| Materials         | Inorganic crystals   | Metal-organic frameworks |
| Key idea    | Crystal symmetry -> asymmetric unit    | MOF modularity -> coarse-graining | 
| Method            | Diffusion            | Diffusion                |
| Model backbone    | Periodic GNN         | GemNet                   | 
| Published in      | ICLR 2025            | ICLR 2024                | 

The purpose of this blogpost is to provide a high-level overview of crystal generative models and how the property of each crystal could be utilized as an inductive bias in the model. It is assumed that many basics are known, such as molecule representation and diffusion models. 

## SymmCD: Symmetry-Preserving Crystal Generation with Diffusion Models

### Preliminary: Crystal representation

To represent a 3D structure of a **molecule** with $$N$$ atoms, we typically specify two things: the atom types $$\bA=(a_1, \dots, a_N) \in \cA^N$$, where each $$\cA$$ is the set of possible elements, and the 3D coordinates of those atoms,  $$\bX=(x_1, \dots, x_N) \in \bbR^{N \times 3}$$. 

Crystals are similar, but with one key addition, side, $$\bA$$ and $$\bX$$, we also need the lattice or the unit cell $$\mathbf{L}=(l_1, l_2, l_3) \in \bbR^{N \times 3}$$.  This compact representation $$\cM = (\bA, \bX, \bL)$$ captures all the necessary information about a crystal without explictly listing its infinitely repeating atoms. To recover the full, infinite structure, we simply have to translate the atoms along the lattice vectors $$l_1, l_2, l_3$$, we can recover the full, infinite crystal structure (Figure).

### Asymmetric unit and site symmetries

While the unit cell representation of a crystal $$\cM = (\bA, \bX, \bL)$$ is compact, SymmCD exploits an even more compact representation of a crystal called the **asymmetric unit**. The asymmetric unit can be replicated to construct the unit cell $$\cM$$, which can then be extended to infinite crystal structure afterward (Image). 

A helpful analogy to better understand the asymmetric unit is making a paper snowflake. Imagine folding a hexagonal sheet into a triangle, then cutting a small shape into it. When you unfold the paper, that shape appears multiple times, arranged symmetrically. In this analogy, the folded triangle represents the asymmetric unit, and unfolding it mimics the symmetry operations used to build a full crystal from its minimal part.

But here’s the subtle part: *where* you make the cut affects how many times it appears in the final pattern. A cut at the center might be repeated six times; one at the edge, only three. In crystallography, this concept is captured by the **site symmetry** -- it tells you how many times an atom is replicated based on its position.

SymmCD leverages these two simple concepts for inorganic crystal generation. Rather than generating the full crystal, it generates just the asymmetric unit, which contains the atom types, coordinates, lattice, and site symmetries. This simplifies the generation process while guaranteeing that the resulting structures are both symmetric and physically valid.

Mathematically, we represent an asymmetric unit with atom types $$\bA' = (a_1, \dots, A_M) \in \cA^M$$, 3D coordinates $$\bX=(x_1, \dots, x_M) \in \bbR^{M \times 3}$$, lattice as $$k \in \mathbb{R}^6$$, and the site symmetries of each atom $$\bS = (S_{x_1'}, \dots, S_{X_M'}) \in \mathcal{P}^M$$ where $$\mathcal{P}$$ denotes the set of all possible site symmetries. Note that $$M \leq N$$ (e.g., $$M=4.7$$ and $$N=18.9$$ on average for MP-20 dataset), since the asymmetric unit is a only a part of the unit cell. Notice that we can use a more compact 6-dimensional representation $$\mathbf{k} \in \bbR^6$$ to represent the lattice cell for a given asymmetric group. 

### Pre-processing: Finding the Asymmetric Unit

Before we can train a model to generate crystals, we first need to define what it should generate. Rather than modeling the full crystal, SymmCD focuses on its minimal building block: the **asymmetric unit**. But *how* do we find that?

It turns out that all crystals—yes, all of them—fall into just 230 possible space groups, each encoding a unique combination of symmetry operations. Given a crystal in unit cell form, $$\cM = (\bA, \bX, \bL)$$, we first identify its space group $$G$$ (there are python packages built for this purpose -- e.g., spglib). This space group tells us how the crystal repeats and, in turn, defines its asymmetric unit.

$$
\begin{equation}
\mathcal{D} = \{ (\bA, \bX, \bL)  \} \Rightarrow{} \mathcal{D} = \{ (G, k, \bA', \bX', \bS)  \}.
\end{equation}
$$

### Training the model

SymmCD models the joint distribution as 
$$
\begin{equation}
p_{\theta}(G, k, \bA', \bX', \bS)=p_{\theta}( k, \bA', \bX', \bS \vert G)p(G).
\end{equation}
$$

In other words, once a space group $$G$$ is specified (or sampled), the model learns to generate the corresponding asymmetric unit. To do this, SymmCD uses a diffusion model, where the atom types and site symmetries $$\bA', \bS$$ are learned with discrete diffusion and the lattice $$k, \bX'$$ are learned with continuous diffusion. 

### Sampling and Post-processing

Generating inorganic crystal structures with SymmCD is straightforward: (1) Choose a space group $$G$$ -- either randomly or specifying, (2) Sample $$(k, \bA', \bX', \bS) \sim p_{\theta}( k, \bA', \bX', \bS \vert G)$$ with the trained diffusion model, and (3) Project atoms into valid **Wyckoff positions** based on their site symmetries. 

Why is this projection needed? Recall the paper snowflake analogy: cuts made at different parts of the folded paper produce different numbers of copies. Similarly, certain regions of the asymmetric unit only permit specific site symmetries. If a generated atom-site symmetry pair is incompatible, we adjust (i.e., project) the atom’s position to a compatible one.

Finally, we replicate the asymmetric unit using its site symmetries to reconstruct the full crystal $$\cM = (\bA, \bX, \bL)$$. By shifting the focus from full crystals to asymmetric unit, SymmCD enjoys higher computational efficiency. 

### Experimental results: what advantages does SymmCD have?

In the experiments, we randomly generate 10,000 crystals in each baseline and identify the proportion of space group symmetries. The experiments show that both SymmCD and DiffCSP++ generates samples with *diverse* space group symmetries. Yet, SymmCD is able to generate more *novel* structures that are not in the training dataset. This is because DiffCSP++ starts with a template extracted from the training dataset and refine it with their model. 

## MOFDiff: Coarse-grained Diffusion for Metal-Organic Framework Design

### Preliminary: MOF representation and key idea. 

MOFs are typicaly larger than inorganic crystals. Therefore, generative models designed for inorganic materials usually suffer from poor performance and scalability with MOFs. 

A fortunate this is that MOFs they can be decomposed into a set of metal nodes and organic linkers (collectively referred to as building blocks hereon). Therefore, while MOFs are crystalline and can also be represented with $$\cM = (\bA, \bX, \bL)$$, we can come up with a simpler representation based on this decomposition.

Specifically, given suppose that a MOF is composed of $$K$$ building blocks. Then, we can represent the MOF with the **coarse-grained representation** as $$\cM^C = (\bA^C, \bX^C, \bL)$$. Here, $$\bA^C = (a_1^C, \dots, a_K^C) \in \mathbb{B}^{K}$$ are the building block identities, where $$\mathbb{B}$$ denotes the set of all building blocks, and $$\bX^C = (x_1^C, \dots x_k^C) \in \bbR^{K \times 3}$$ are the coordinates of the building blocks, and $$\bL$$ is the same lattice parameter. Since the number of building blocks is generally orders of magnitudes smaller than the number of atoms -- i.e., $$K \ll N$$ -- learning this **coarse-grained representation** will be much more efficient than learning all atom positions. 

The key idea of MOFDiff is exactly this -- it aims to learn this coarse-grained representation with a diffusion model -- i.e., $$p_{\theta}(\cM^C) = p_{\theta}(\bA^C, \bX^C, \bL)$$. It then fills in the fine-level details with two additional post processing steps: (1) the self-assembly algorithm that determines the *orientation* of each building block and (2) a force field relaxation for fine grained control of atomic coordinates. 

### Learning building block representations

A naive approach to learn coarse-grained representation $$\cM^C = (\bA^C, \bX^C, \bL)$$ is to simply collect all building blocks from the training dataset, and encode the building block type with one-hot representation, and learn a diffusion model by discrete diffusion for the building block type $$\bA^C$$ and continuous diffusion for building block coordinates and lattice $$\bX^C, \bL$$. 

The problem with this approach is that MOFs have *many* types of building blocks -- e.g., 2M building blocks from the training dataset with 289k MOFs. This makes the one-hot representation inefficient and difficult to learn due to very high sparsity. Also, many building blocks extracted from the dataset has exact same 2D graph topology -- i.e., atom types and bonds -- with only a slight difference in coordinates (Image). MOFDiff resolves this by learning a *denser* representation of the building blocks that can capture similarities between building blocks with same topologies. 

Specifically, after extracting the 2M building blocks from the training dataset, MOFDiff uses contrastive learning to learn this denser representation of the building blocks. Namely, it trains a SE(3)-invariant graph neural network that takes as input the building block structure and outputs a dense embedding for that building block. The key idea is to train this model so that building blocks with similar topologies are embedded close to each other in the embedding space. More speficially, the determine a building blocks' topology with ECFP4 fingerprint, and use the contrastive loss such that building blocks with similar ECFP4 fingerprint are embedded close to each other in the embedding space. 

$$
\begin{equation}
  p_{\theta}(G, k, \bA', \bX', \bS)=p_{\theta}( k, \bA', \bX', \bS \vert G)p(G).
\end{equation}
$$
